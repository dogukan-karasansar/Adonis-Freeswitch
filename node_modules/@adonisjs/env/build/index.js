import {
  EnvLoader,
  __export,
  debug_default
} from "./chunk-H6UKLEIO.js";

// src/env.ts
import { schema as envSchema } from "@poppinss/validator-lite";

// src/errors.ts
var errors_exports = {};
__export(errors_exports, {
  E_INVALID_ENV_VARIABLES: () => E_INVALID_ENV_VARIABLES
});
import { Exception } from "@poppinss/utils";
var E_INVALID_ENV_VARIABLES = class EnvValidationException extends Exception {
  static message = "Validation failed for one or more environment variables";
  static code = "E_INVALID_ENV_VARIABLES";
  help = "";
};

// src/validator.ts
var EnvValidator = class {
  #schema;
  #error;
  constructor(schema) {
    this.#schema = schema;
    this.#error = new E_INVALID_ENV_VARIABLES();
  }
  /**
   * Accepts an object of values to validate against the pre-defined
   * schema.
   *
   * The return value is a merged copy of the original object and the
   * values mutated by the schema validator.
   */
  validate(values) {
    const help = [];
    const validated = Object.keys(this.#schema).reduce(
      (result, key) => {
        const value = process.env[key] || values[key];
        try {
          result[key] = this.#schema[key](key, value);
        } catch (error) {
          help.push(`- ${error.message}`);
        }
        return result;
      },
      { ...values }
    );
    if (help.length) {
      this.#error.help = help.join("\n");
      throw this.#error;
    }
    return validated;
  }
};

// src/parser.ts
import dotenv from "dotenv";
var EnvParser = class {
  #envContents;
  #preferProcessEnv = true;
  constructor(envContents, options) {
    if (options?.ignoreProcessEnv) {
      this.#preferProcessEnv = false;
    }
    this.#envContents = envContents;
  }
  /**
   * Returns the value from the parsed object
   */
  #getValue(key, parsed) {
    if (this.#preferProcessEnv && process.env[key]) {
      return process.env[key];
    }
    if (parsed[key]) {
      return this.#interpolate(parsed[key], parsed);
    }
    return process.env[key] || "";
  }
  /**
   * Interpolating the token wrapped inside the mustache braces.
   */
  #interpolateMustache(token, parsed) {
    const closingBrace = token.indexOf("}");
    if (closingBrace === -1) {
      return token;
    }
    const varReference = token.slice(1, closingBrace).trim();
    return `${this.#getValue(varReference, parsed)}${token.slice(closingBrace + 1)}`;
  }
  /**
   * Interpolating the variable reference starting with a
   * `$`. We only capture numbers,letter and underscore.
   * For other characters, one can use the mustache
   * braces.
   */
  #interpolateVariable(token, parsed) {
    return token.replace(/[a-zA-Z0-9_]+/, (key) => {
      return this.#getValue(key, parsed);
    });
  }
  /**
   * Interpolates the referenced values
   */
  #interpolate(value, parsed) {
    const tokens = value.split("$");
    let newValue = "";
    let skipNextToken = true;
    tokens.forEach((token) => {
      if (token === "\\") {
        newValue += "$";
        skipNextToken = true;
        return;
      }
      if (skipNextToken) {
        newValue += token.replace(/\\$/, "$");
        if (token.endsWith("\\")) {
          return;
        }
      } else {
        if (token.startsWith("{")) {
          newValue += this.#interpolateMustache(token, parsed);
          return;
        }
        newValue += this.#interpolateVariable(token, parsed);
      }
      skipNextToken = false;
    });
    return newValue;
  }
  /**
   * Parse the env string to an object of environment variables.
   */
  parse() {
    const envCollection = dotenv.parse(this.#envContents.trim());
    return Object.keys(envCollection).reduce((result, key) => {
      result[key] = this.#getValue(key, envCollection);
      return result;
    }, {});
  }
};

// src/processor.ts
var EnvProcessor = class {
  /**
   * App root is needed to load files
   */
  #appRoot;
  constructor(appRoot) {
    this.#appRoot = appRoot;
  }
  /**
   * Parse env variables from raw contents
   */
  #processContents(envContents, store) {
    if (!envContents.trim()) {
      return store;
    }
    const values = new EnvParser(envContents).parse();
    Object.keys(values).forEach((key) => {
      let value = process.env[key];
      if (!value) {
        value = values[key];
        process.env[key] = values[key];
      }
      if (!store[key]) {
        store[key] = value;
      }
    });
    return store;
  }
  /**
   * Parse env variables by loading dot files.
   */
  async #loadAndProcessDotFiles() {
    const loader = new EnvLoader(this.#appRoot);
    const envFiles = await loader.load();
    if (debug_default.enabled) {
      debug_default(
        "processing .env files (priority from top to bottom) %O",
        envFiles.map((file) => file.path)
      );
    }
    const envValues = {};
    envFiles.forEach(({ contents }) => this.#processContents(contents, envValues));
    return envValues;
  }
  /**
   * Process env variables
   */
  async process() {
    return this.#loadAndProcessDotFiles();
  }
};

// src/env.ts
var Env = class _Env {
  /**
   * A cache of env values
   */
  #values;
  constructor(values) {
    this.#values = values;
  }
  /**
   * Create an instance of the env class by validating the
   * environment variables. Also, the `.env` files are
   * loaded from the appRoot
   */
  static async create(appRoot, schema) {
    const values = await new EnvProcessor(appRoot).process();
    const validator = this.rules(schema);
    return new _Env(validator.validate(values));
  }
  /**
   * The schema builder for defining validation rules
   */
  static schema = envSchema;
  /**
   * Define the validation rules for validating environment
   * variables. The return value is an instance of the
   * env validator
   */
  static rules(schema) {
    const validator = new EnvValidator(schema);
    return validator;
  }
  get(key, defaultValue) {
    if (this.#values[key] !== void 0) {
      return this.#values[key];
    }
    const envValue = process.env[key];
    if (envValue) {
      return envValue;
    }
    return defaultValue;
  }
  set(key, value) {
    this.#values[key] = value;
    process.env[key] = value;
  }
};
export {
  Env,
  EnvLoader,
  EnvParser,
  EnvProcessor,
  errors_exports as errors
};
//# sourceMappingURL=index.js.map