{"version":3,"sources":["../src/env.ts","../src/errors.ts","../src/validator.ts","../src/parser.ts","../src/processor.ts"],"sourcesContent":["/*\n * @adonisjs/env\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { schema as envSchema, type ValidateFn } from '@poppinss/validator-lite'\nimport { EnvValidator } from './validator.js'\nimport { EnvProcessor } from './processor.js'\n\n/**\n * A wrapper over \"process.env\" with types information.\n *\n * ```ts\n * const validate = Env.rules({\n *   PORT: Env.schema.number()\n * })\n *\n * const validatedEnvVars = validate(process.env)\n *\n * const env = new EnvValues(validatedEnvVars)\n * env.get('PORT') // type === number\n * ```\n */\nexport class Env<EnvValues extends Record<string, any>> {\n  /**\n   * A cache of env values\n   */\n  #values: EnvValues\n\n  constructor(values: EnvValues) {\n    this.#values = values\n  }\n\n  /**\n   * Create an instance of the env class by validating the\n   * environment variables. Also, the `.env` files are\n   * loaded from the appRoot\n   */\n  static async create<Schema extends { [key: string]: ValidateFn<unknown> }>(\n    appRoot: URL,\n    schema: Schema\n  ): Promise<\n    Env<{\n      [K in keyof Schema]: ReturnType<Schema[K]>\n    }>\n  > {\n    const values = await new EnvProcessor(appRoot).process()\n    const validator = this.rules(schema)\n    return new Env(validator.validate(values))\n  }\n\n  /**\n   * The schema builder for defining validation rules\n   */\n  static schema = envSchema\n\n  /**\n   * Define the validation rules for validating environment\n   * variables. The return value is an instance of the\n   * env validator\n   */\n  static rules<T extends { [key: string]: ValidateFn<unknown> }>(schema: T): EnvValidator<T> {\n    const validator = new EnvValidator<T>(schema)\n    return validator\n  }\n\n  /**\n   * Get the value of an environment variable by key. The values are\n   * lookedup inside the validated environment and \"process.env\"\n   * is used as a fallback.\n   *\n   * The second param is the default value, which is returned when\n   * the environment variable does not exist.\n   *\n   * ```ts\n   * Env.get('PORT')\n   *\n   * // With default value\n   * Env.get('PORT', 3000)\n   * ```\n   */\n  get<K extends keyof EnvValues>(key: K): EnvValues[K]\n  get<K extends keyof EnvValues>(\n    key: K,\n    defaultValue: Exclude<EnvValues[K], undefined>\n  ): Exclude<EnvValues[K], undefined>\n  get(key: string): string | undefined\n  get(key: string, defaultValue: string): string\n  get(key: string, defaultValue?: any): any {\n    /**\n     * Return cached value\n     */\n    if (this.#values[key] !== undefined) {\n      return this.#values[key]\n    }\n\n    /**\n     * Get value from \"process.env\" and update the cache\n     */\n    const envValue = process.env[key]\n    if (envValue) {\n      return envValue\n    }\n\n    /**\n     * Return default value when unable to lookup any other value\n     */\n    return defaultValue\n  }\n\n  /**\n   * Update/set value of an environment variable.\n   *\n   * The value is not casted/validated using the validator, so make sure\n   * to set the correct data type.\n   *\n   * ```ts\n   * Env.set('PORT', 3000)\n   *\n   * Env.get('PORT') === 3000 // true\n   * process.env.PORT === '3000' // true\n   * ```\n   */\n  set<K extends keyof EnvValues>(key: K, value: EnvValues[K]): void\n  set(key: string, value: string): void\n  set(key: string | keyof EnvValues, value: any): void {\n    this.#values[key] = value\n    process.env[key as string] = value\n  }\n}\n","/*\n * @adonisjs/env\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Exception } from '@poppinss/utils'\n\n/**\n * Exception raised when one or more env variables\n * are invalid\n */\nexport const E_INVALID_ENV_VARIABLES = class EnvValidationException extends Exception {\n  static message = 'Validation failed for one or more environment variables'\n  static code = 'E_INVALID_ENV_VARIABLES'\n  help: string = ''\n}\n","/*\n * @adonisjs/env\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Exception } from '@poppinss/utils'\nimport { ValidateFn } from '@poppinss/validator-lite'\n\nimport { E_INVALID_ENV_VARIABLES } from './errors.js'\n\n/**\n * Exposes the API to validate environment variables against a\n * pre-defined schema.\n *\n * The class is not exported in the main API and used internally.\n */\nexport class EnvValidator<Schema extends { [key: string]: ValidateFn<unknown> }> {\n  #schema: Schema\n  #error: Exception\n\n  constructor(schema: Schema) {\n    this.#schema = schema\n    this.#error = new E_INVALID_ENV_VARIABLES()\n  }\n\n  /**\n   * Accepts an object of values to validate against the pre-defined\n   * schema.\n   *\n   * The return value is a merged copy of the original object and the\n   * values mutated by the schema validator.\n   */\n  validate(values: { [K: string]: string | undefined }): {\n    [K in keyof Schema]: ReturnType<Schema[K]>\n  } {\n    const help: string[] = []\n\n    const validated = Object.keys(this.#schema).reduce(\n      (result, key) => {\n        const value = process.env[key] || values[key]\n\n        try {\n          result[key] = this.#schema[key](key, value) as any\n        } catch (error) {\n          help.push(`- ${error.message}`)\n        }\n        return result\n      },\n      { ...values }\n    ) as { [K in keyof Schema]: ReturnType<Schema[K]> }\n\n    if (help.length) {\n      this.#error.help = help.join('\\n')\n      throw this.#error\n    }\n\n    return validated\n  }\n}\n","/*\n * @adonisjs/env\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport dotenv, { DotenvParseOutput } from 'dotenv'\n\n/**\n * Env parser parses the environment variables from a string formatted\n * as a key-value pair seperated using an `=`. For example:\n *\n * ```dotenv\n * PORT=3333\n * HOST=127.0.0.1\n * ```\n *\n * The variables can reference other environment variables as well using `$`.\n * For example:\n *\n * ```dotenv\n * PORT=3333\n * REDIS_PORT=$PORT\n * ```\n *\n * The variables using characters other than letters can wrap variable\n * named inside a curly brace.\n *\n * ```dotenv\n * APP-PORT=3333\n * REDIS_PORT=${APP-PORT}\n * ```\n *\n * You can escape the `$` sign with a backtick.\n *\n * ```dotenv\n * REDIS_PASSWORD=foo\\$123\n * ```\n *\n * ## Usage\n *\n * ```ts\n * const parser = new EnvParser(envContents)\n * const output = parser.parse()\n *\n * // The output is a key-value pair\n * ```\n */\nexport class EnvParser {\n  #envContents: string\n  #preferProcessEnv: boolean = true\n\n  constructor(envContents: string, options?: { ignoreProcessEnv: boolean }) {\n    if (options?.ignoreProcessEnv) {\n      this.#preferProcessEnv = false\n    }\n\n    this.#envContents = envContents\n  }\n\n  /**\n   * Returns the value from the parsed object\n   */\n  #getValue(key: string, parsed: DotenvParseOutput): string {\n    if (this.#preferProcessEnv && process.env[key]) {\n      return process.env[key]!\n    }\n\n    if (parsed[key]) {\n      return this.#interpolate(parsed[key], parsed)\n    }\n\n    return process.env[key] || ''\n  }\n\n  /**\n   * Interpolating the token wrapped inside the mustache braces.\n   */\n  #interpolateMustache(token: string, parsed: DotenvParseOutput) {\n    /**\n     * Finding the closing brace. If closing brace is missing, we\n     * consider the block as a normal string\n     */\n    const closingBrace = token.indexOf('}')\n    if (closingBrace === -1) {\n      return token\n    }\n\n    /**\n     * Then we pull everything until the closing brace, except\n     * the opening brace and trim off all white spaces.\n     */\n    const varReference = token.slice(1, closingBrace).trim()\n\n    /**\n     * Getting the value of the reference inside the braces\n     */\n    return `${this.#getValue(varReference, parsed)}${token.slice(closingBrace + 1)}`\n  }\n\n  /**\n   * Interpolating the variable reference starting with a\n   * `$`. We only capture numbers,letter and underscore.\n   * For other characters, one can use the mustache\n   * braces.\n   */\n  #interpolateVariable(token: string, parsed: any) {\n    return token.replace(/[a-zA-Z0-9_]+/, (key) => {\n      return this.#getValue(key, parsed)\n    })\n  }\n\n  /**\n   * Interpolates the referenced values\n   */\n  #interpolate(value: string, parsed: DotenvParseOutput): string {\n    const tokens = value.split('$')\n\n    let newValue = ''\n    let skipNextToken = true\n\n    tokens.forEach((token) => {\n      /**\n       * If the value is an escaped sequence, then we replace it\n       * with a `$` and then skip the next token.\n       */\n      if (token === '\\\\') {\n        newValue += '$'\n        skipNextToken = true\n        return\n      }\n\n      /**\n       * Use the value as it is when \"skipNextToken\" is set to true.\n       */\n      if (skipNextToken) {\n        /**\n         * Replace the ending escape sequence with a $\n         */\n        newValue += token.replace(/\\\\$/, '$')\n        /**\n         *  and then skip the next token if it ends with escape sequence\n         */\n        if (token.endsWith('\\\\')) {\n          return\n        }\n      } else {\n        /**\n         * Handle mustache block\n         */\n        if (token.startsWith('{')) {\n          newValue += this.#interpolateMustache(token, parsed)\n          return\n        }\n\n        /**\n         * Process all words as variable\n         */\n        newValue += this.#interpolateVariable(token, parsed)\n      }\n\n      /**\n       * Process next token\n       */\n      skipNextToken = false\n    })\n\n    return newValue\n  }\n\n  /**\n   * Parse the env string to an object of environment variables.\n   */\n  parse(): DotenvParseOutput {\n    const envCollection = dotenv.parse(this.#envContents.trim())\n\n    return Object.keys(envCollection).reduce<DotenvParseOutput>((result, key) => {\n      result[key] = this.#getValue(key, envCollection)\n      return result\n    }, {})\n  }\n}\n","/*\n * @adonisjs/application\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport debug from './debug.js'\nimport { EnvParser } from './parser.js'\nimport { EnvLoader } from './loader.js'\n\n/**\n * Env processors loads, parses and process environment variables.\n */\nexport class EnvProcessor {\n  /**\n   * App root is needed to load files\n   */\n  #appRoot: URL\n\n  constructor(appRoot: URL) {\n    this.#appRoot = appRoot\n  }\n\n  /**\n   * Parse env variables from raw contents\n   */\n  #processContents(envContents: string, store: Record<string, any>) {\n    /**\n     * Collected env variables\n     */\n    if (!envContents.trim()) {\n      return store\n    }\n\n    const values = new EnvParser(envContents).parse()\n    Object.keys(values).forEach((key) => {\n      let value = process.env[key]\n\n      if (!value) {\n        value = values[key]\n        process.env[key] = values[key]\n      }\n\n      if (!store[key]) {\n        store[key] = value\n      }\n    })\n\n    return store\n  }\n\n  /**\n   * Parse env variables by loading dot files.\n   */\n  async #loadAndProcessDotFiles() {\n    const loader = new EnvLoader(this.#appRoot)\n    const envFiles = await loader.load()\n\n    if (debug.enabled) {\n      debug(\n        'processing .env files (priority from top to bottom) %O',\n        envFiles.map((file) => file.path)\n      )\n    }\n\n    /**\n     * Collected env variables\n     */\n    const envValues: Record<string, any> = {}\n    envFiles.forEach(({ contents }) => this.#processContents(contents, envValues))\n    return envValues\n  }\n\n  /**\n   * Process env variables\n   */\n  async process() {\n    return this.#loadAndProcessDotFiles()\n  }\n}\n"],"mappings":"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","names":[]}